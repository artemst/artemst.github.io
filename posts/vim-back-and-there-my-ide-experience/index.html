<!DOCTYPE html><html lang="ru-RU"> <head prefix="og: http://ogp.me/ns#"><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="generator" content="Astro v3.6.5"><title>System Out • Vim – туда и обратно. Мой опыт использования Vim в качестве IDE.</title><meta name="description" content="Рассказ о том, как я использовал текстовый редактора Vim в качестве IDE для написания кода: почему решил попробовать, почему именно Vim, с чего начинал и к чему в итоге пришёл."><link rel="canonical" href="https://systemout.blog/posts/vim-back-and-there-my-ide-experience/"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="sitemap" href="/sitemap-index.xml"><meta property="telegram:channel" content="@SystemOutBlog"><meta property="og:site_name" content="SystemOut.blog"><meta property="og:title" content="Vim – туда и обратно. Мой опыт использования Vim в качестве IDE."><meta property="og:description" content="Рассказ о том, как я использовал текстовый редактора Vim в качестве IDE для написания кода: почему решил попробовать, почему именно Vim, с чего начинал и к чему в итоге пришёл."><meta property="og:type" content="website"><meta property="og:image" content="https://systemout.blog/_astro/01-1-vim-road-to-ide.89ad2e25.png">
            <meta name="twitter:image" content="https://systemout.blog/_astro/01-1-vim-road-to-ide.89ad2e25.png">
            <meta name="twitter:card" content="summary_large_image"><!-- Yandex.Metrika counter -->
            <script type="text/javascript">
               (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
               m[i].l=1*new Date();
               for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
               k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
               (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

               ym(96019340, "init", {
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true
               });
            </script>
            <noscript><div><img src="https://mc.yandex.ru/watch/96019340" style="position:absolute; left:-9999px;" alt=""></div></noscript>
            <!-- /Yandex.Metrika counter --><link rel="stylesheet" href="/_astro/about.f1b67427.css" /><script type="module">const t="max-lg:hidden",e=document.querySelector("#menuBarButton"),n=document.querySelector("#menuBarNav");e!==void 0&&e&&n!==void 0&&n&&(console.log("Add menuBarButton click handler"),e.addEventListener("click",()=>{n.classList.toggle(t)}));
</script>
<script type="module" src="/_astro/page.30c903a1.js"></script></head> <body class="bg-stone-100"> <div class="md:container md:mx-auto xl:max-w-screen-xl"> <header class="bg-sidebar-main text-white
        lg:fixed lg:flex lg:h-full
        lg:max-h-screen lg:min-h-screen
        lg:w-64 lg:flex-col lg:overflow-y-auto
        lg:text-center lg:scrollbar-hide xl:w-72"> <div class="h-24
        max-lg:flex sm:px-4
        lg:h-auto"> <div class="h-full
                w-24 bg-logo bg-contain bg-left
                bg-no-repeat max-lg:ml-2
                max-[289px]:hidden xs:w-28 md:w-32
                lg:mt-6 lg:h-40 lg:w-full lg:bg-center xl:mt-8"></div> <div class="grow self-center max-lg:ml-12 max-lg:mr-6 max-sm:ml-4"> <div class="font-sans text-2xl
                    font-bold drop-shadow-lg max-lg:tracking-wide sm:text-3xl md:text-[2rem] lg:pt-6
                    xl:pt-8 xl:text-[2.1rem] xl:tracking-wide"> <a href="/" class="text-white no-underline
                        lg:before:content-['•'] lg:after:content-['•']">
System&nbsp;Out
</a> </div> <div class="pt-1
                    text-xs tracking-wide
                    text-gray-100
                    drop-shadow-md max-xs:hidden lg:mt-4
                    lg:text-sm lg:leading-tight xl:text-[0.95rem]">
Yet another dev blog
</div> </div> <button id="menuBarButton" type="button" title="Меню" class="self-center rounded-md border border-gray-400
                    max-sm:mr-4 sm:mr-1 lg:hidden"> <svg class="m-2 w-6 text-stone-200 drop-shadow-md" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M3 18v-2h18v2Zm0-5v-2h18v2Zm0-5V6h18v2Z"></path></svg> </button> </div> <div id="menuBarNav" class="pt-4 max-lg:hidden lg:my-16"> <nav class="text-center
                text-lg tracking-wide
                drop-shadow-lg lg:text-[1.35rem]"> <ul class="list-none pl-0 decoration-1 underline-offset-4
                    [&>*]:pb-2 [&>*]:lg:pb-3 [&>li>*]:text-white"> <li> <a class="text-white" href="/" rel="prefetch">Главная</a> </li> <li><a href="/posts/" rel="prefetch">Cтатьи</a></li> <li><a href="/about/">Обо мне</a></li> </ul> </nav> <div class="mt-6 flex justify-center py-4 drop-shadow-md
                lg:mt-20 [&>*]:mx-3 [&>*]:w-6
                [&>*]:text-white [&>*]:lg:w-7"> <!--            <a href="#" title="GitHub: <name>" target="_blank">--> <!--                <GitHubIcon class="hover:scale-150"></GitHubIcon>--> <!--            </a>--> <!--
            <a
                href="https://mastodon.world/@systemout"
                title="Mastodon: @systemout"
            >
                <MastodonIcon class="hover:scale-150" />
            </a>
            --> <a href="mailto:artemst88@yandex.ru" class="font-bold" title="Email me" target="_blank"> <svg class="hover:scale-150" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path fill="currentColor" d="M14.608 12.172c0 .84.239 1.175.864 1.175c1.393 0 2.28-1.775 2.28-4.727c0-4.512-3.288-6.672-7.393-6.672c-4.223 0-8.064 2.832-8.064 8.184c0 5.112 3.36 7.896 8.52 7.896c1.752 0 2.928-.192 4.727-.792l.386 1.607c-1.776.577-3.674.744-5.137.744c-6.768 0-10.393-3.72-10.393-9.456c0-5.784 4.201-9.72 9.985-9.72c6.024 0 9.215 3.6 9.215 8.016c0 3.744-1.175 6.6-4.871 6.6c-1.681 0-2.784-.672-2.928-2.161c-.432 1.656-1.584 2.161-3.145 2.161c-2.088 0-3.84-1.609-3.84-4.848c0-3.264 1.537-5.28 4.297-5.28c1.464 0 2.376.576 2.782 1.488l.697-1.272h2.016v7.057h.002zm-2.951-3.168c0-1.319-.985-1.872-1.801-1.872c-.888 0-1.871.719-1.871 2.832c0 1.68.744 2.616 1.871 2.616c.792 0 1.801-.504 1.801-1.896v-1.68z"></path></svg> </a> <a href="https://t.me/SystemOutBlog" title="Подписывайся на Telegram: SystemOutBlog" target="_blank"> <svg class="hover:scale-150" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.64 6.8c-.15 1.58-.8 5.42-1.13 7.19-.14.75-.42 1-.68 1.03-.58.05-1.02-.38-1.58-.75-.88-.58-1.38-.94-2.23-1.5-.99-.65-.35-1.01.22-1.59.15-.15 2.71-2.48 2.76-2.69a.2.2 0 0 0-.05-.18c-.06-.05-.14-.03-.21-.02-.09.02-1.49.95-4.22 2.79-.4.27-.76.41-1.08.4-.36-.01-1.04-.2-1.55-.37-.63-.2-1.12-.31-1.08-.66.02-.18.27-.36.74-.55 2.92-1.27 4.86-2.11 5.83-2.51 2.78-1.16 3.35-1.36 3.73-1.36.08 0 .27.02.39.12.1.08.13.19.14.27-.01.06.01.24 0 .38z"></path></svg> </a> <a href="/rss.xml" title="RSS Feed: System Out Blog" target="_blank"> <svg class="hover:scale-150" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M5 21q-.825 0-1.413-.587Q3 19.825 3 19q0-.825.587-1.413Q4.175 17 5 17q.825 0 1.412.587Q7 18.175 7 19q0 .825-.588 1.413Q5.825 21 5 21Zm12 0q0-2.9-1.1-5.438q-1.1-2.537-3.012-4.45Q10.975 9.2 8.438 8.1Q5.9 7 3 7V4q3.525 0 6.625 1.338q3.1 1.337 5.4 3.637q2.3 2.3 3.638 5.4Q20 17.475 20 21Zm-6 0q0-3.325-2.338-5.662Q6.325 13 3 13v-3q2.3 0 4.3.863q2 .862 3.488 2.349q1.487 1.488 2.349 3.488Q14 18.7 14 21Z"></path></svg> </a> </div> </div> <div class="mb-8 flex h-full flex-col justify-end max-lg:hidden"> <a href="https://www.vecteezy.com/free-vector/free" class="text-xs text-stone-200" target="_blank">
Free Vectors by Vecteezy
</a> <p class="mt-2 text-center text-sm text-stone-100 drop-shadow-md">
&#169; 2024 System Out
</p> </div> </header>  <main class="bg-white w-full
                    lg:min-h-screen lg:block lg:pl-64 xl:pl-72"> <section class="max-lg:min-h-[85vh]
					px-4 sm:px-6 md:px-10 lg:px-12
					pt-6 lg:pt-10
					pb-14">  <article> <div class="flex items-center place-content-between"> <div class="inline-flex flex-shrink-0 mr-6"> <svg class="inline w-5 text-zinc-500 mr-1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><rect width="416" height="384" x="48" y="80" fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="32" rx="48"></rect><circle cx="296" cy="232" r="24" fill="currentColor"></circle><circle cx="376" cy="232" r="24" fill="currentColor"></circle><circle cx="296" cy="312" r="24" fill="currentColor"></circle><circle cx="376" cy="312" r="24" fill="currentColor"></circle><circle cx="136" cy="312" r="24" fill="currentColor"></circle><circle cx="216" cy="312" r="24" fill="currentColor"></circle><circle cx="136" cy="392" r="24" fill="currentColor"></circle><circle cx="216" cy="392" r="24" fill="currentColor"></circle><circle cx="296" cy="392" r="24" fill="currentColor"></circle><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="M128 48v32m256-32v32"></path><path fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="32" d="M464 160H48"></path></svg> <span class="xs:hidden pt-1 text-sm text-zinc-500 ml-1"> 06.09.23 </span> <span class="max-xs:hidden pt-1 text-sm text-zinc-500 ml-1"> 6 сентября 2023 г. </span> </div> <a class="mr-3 text-sm text-zinc-600 no-underline" id="go-back" href="#">
⇦&nbsp;Назад
</a> <script lang="ts">
    document
        .getElementById('go-back')
        .addEventListener('click', () => window.history.back());
</script> </div> <h1 class="text-balance">Vim – туда и обратно. Мой опыт использования Vim в качестве IDE.</h1> <div class="mb-4 text-base"><a class="mb-1 mr-3 inline-block rounded-md border-solid border-header-blue bg-header-blue/10 pl-2 pr-3 text-sidebar-main no-underline hover:bg-header-blue/20" href="/tags/vim/"><svg class="mr-2 inline w-4 text-sidebar-main" xmlns="http://www.w3.org/2000/svg" style="vertical-align: -0.2em;" viewBox="0 0 24 24"><path fill="currentColor" d="M19.75 2A2.25 2.25 0 0 1 22 4.25v5.462a3.25 3.25 0 0 1-.952 2.298l-8.5 8.503a3.255 3.255 0 0 1-4.597.001L3.489 16.06a3.25 3.25 0 0 1-.004-4.596l8.5-8.51a3.25 3.25 0 0 1 2.3-.953h5.465Zm0 1.5h-5.466c-.464 0-.91.185-1.238.513l-8.512 8.523a1.75 1.75 0 0 0 .015 2.462l4.461 4.454a1.755 1.755 0 0 0 2.477 0l8.5-8.503a1.75 1.75 0 0 0 .513-1.237V4.25a.75.75 0 0 0-.75-.75ZM17 5.502a1.5 1.5 0 1 1 0 3a1.5 1.5 0 0 1 0-3Z"></path></svg> vim  </a><a class="mb-1 mr-3 inline-block rounded-md border-solid border-header-blue bg-header-blue/10 pl-2 pr-3 text-sidebar-main no-underline hover:bg-header-blue/20" href="/tags/ide/"><svg class="mr-2 inline w-4 text-sidebar-main" xmlns="http://www.w3.org/2000/svg" style="vertical-align: -0.2em;" viewBox="0 0 24 24"><path fill="currentColor" d="M19.75 2A2.25 2.25 0 0 1 22 4.25v5.462a3.25 3.25 0 0 1-.952 2.298l-8.5 8.503a3.255 3.255 0 0 1-4.597.001L3.489 16.06a3.25 3.25 0 0 1-.004-4.596l8.5-8.51a3.25 3.25 0 0 1 2.3-.953h5.465Zm0 1.5h-5.466c-.464 0-.91.185-1.238.513l-8.512 8.523a1.75 1.75 0 0 0 .015 2.462l4.461 4.454a1.755 1.755 0 0 0 2.477 0l8.5-8.503a1.75 1.75 0 0 0 .513-1.237V4.25a.75.75 0 0 0-.75-.75ZM17 5.502a1.5 1.5 0 1 1 0 3a1.5 1.5 0 0 1 0-3Z"></path></svg> IDE  </a><a class="mb-1 mr-3 inline-block rounded-md border-solid border-header-blue bg-header-blue/10 pl-2 pr-3 text-sidebar-main no-underline hover:bg-header-blue/20" href="/tags/command-line/"><svg class="mr-2 inline w-4 text-sidebar-main" xmlns="http://www.w3.org/2000/svg" style="vertical-align: -0.2em;" viewBox="0 0 24 24"><path fill="currentColor" d="M19.75 2A2.25 2.25 0 0 1 22 4.25v5.462a3.25 3.25 0 0 1-.952 2.298l-8.5 8.503a3.255 3.255 0 0 1-4.597.001L3.489 16.06a3.25 3.25 0 0 1-.004-4.596l8.5-8.51a3.25 3.25 0 0 1 2.3-.953h5.465Zm0 1.5h-5.466c-.464 0-.91.185-1.238.513l-8.512 8.523a1.75 1.75 0 0 0 .015 2.462l4.461 4.454a1.755 1.755 0 0 0 2.477 0l8.5-8.503a1.75 1.75 0 0 0 .513-1.237V4.25a.75.75 0 0 0-.75-.75ZM17 5.502a1.5 1.5 0 1 1 0 3a1.5 1.5 0 0 1 0-3Z"></path></svg> command-line  </a></div>  <div class="pt-4 pb-2"> <img src="/_astro/01-1-vim-road-to-ide.89ad2e25_123Gwv.webp" class="w-full h-full" alt="Vim IDE" width="1013" height="659" loading="lazy" decoding="async"> </div> <div><p>В этой статье я хотел бы рассказать про свой опыт использования текстового редактора Vim в качестве IDE для написания кода: почему решил попробовать другую для себя IDE, почему именно Vim, с чего начинал и к чему в итоге пришёл.<br/>Также поделюсь подсказками для тех, кто собирается или соберётся после прочтения статьи повторить это увлекательное путешествие. <br/><br/>Осторожно! Будет много текста! Располагайтесь поудобнее, путешествие начинается.</p>
</div> <h2 id="давным-давно">Давным-давно…</h2>
<p>Году эдак в 2010м, когда я был молодым, зелёным и работал в проекте PL/SQL разработчиком, мой тим лид решил сделать из меня Java программиста. Мне выделили наставника в проекте, который учил меня всяким премудростям работы как с самим языком программирования, так и с подручными инструментами.<br>
В те времена джависты в подавляющем большинстве работали в IDE Eclipse. Но некоторые открывали для себя IntelliJ IDEA от компании JetBrains, которая казалась более удобной и местами более продвинутой в части дополнения и анализа кода.<br>
В нашем проекте почти все работали в Eclipse, но мой наставник первым делом сказал мне установить IntelliJ IDEA и работать в ней. Так и случилось моё первое знакомство с IDEA, которую я полюбил и которую как раньше, так и сейчас считаю лучшей IDE из всех доступных вариантов. До недавнего времени я был счастливым обладателем лицензии All Products Pack, которая включает в себя все IDE компании, и даже не помышлял смотреть в другую сторону.</p>
<p>Но всё течёт, всё меняется, настали неспокойные времена, и в 2022 году по известным причинам компания JetBrains ушла из России, из-за чего стало невозможно покупать новые или продлевать имеющиеся лицензии. По началу я не заметил каких-то изменений, так как моя лицензия полноценно действовала до конца года, а по истечении этого времени позволяла продолжать пользоваться всеми продуктами без возможности обновления на новые версии.<br>
Но внезапно я открыл для себя разработку сайтов на фреймворке Astro. О самом фреймворке я расскажу как-нибудь отдельно, а сейчас важно только то, что в 2022м году в WebStorm (IDE от JetBrains для web разработки) не было поддержки Astro, добавили её только в новые версии, выпущенные в 2023 году.<br>
Таким образом я оказался на распутье: либо искать обходные пути продления лицензии, либо продолжать использовать текущую лицензию, при этом работая с файлами astro как с обычными текстовыми файлами (без автодополнения, подсветки синтаксиса, валидации и т.п.), либо пробовать что-то другое, например VS Code, в котором есть полноценная поддержка Astro.<br>
Оставив первые два варианта про запас, впервые за долгое время я решил посмотреть на альтернативы.</p>
<h2 id="а-можно-всех-посмотреть">А можно всех посмотреть?</h2>
<p>По началу складывается впечатление, что сейчас выбора нет вообще. Нишу бесплатных IDE безраздельно занял VS Code. Единственная “альтернатива” – это VSCodium – open source вариант VS Code без проприетарных кусков кода с телеметрией и прочей <del>анализирующей ваше поведение для дальнейшего улучшения вашего опыта использования</del> следящей ерундой от Microsoft.<br>
В дальнейшем я буду для простоты писать VS Code, но подразумевать буду при этом VSCodium, именно его я опробовал в первую очередь.</p>
<p>Я не буду много рассказывать про мой опыт с VS Cоde, так как статья не про него. Скажу лишь, что на итог мне не понравилось.<br>
Нет, не поймите меня неправильно, это прекрасная IDE, особенно учитывая, что за неё не просят ни копейки. Все разработчики новых языков, фреймворков и различного рода инструментов первым делом пишут плагин для VS Code. По своему качеству и возможностям VS Code максимально приблизилась к продуктам JetBrains.<br>
Более того, в новых версиях JetBrains представили альтернативный UI для своих IDE, который практически повторяет UI VS Code. Получается в чем-то VS Code стала даже лучше платных IDE.</p>
<p>Да, это всё так. Но если опираться не на факты и разумные доводы, а на свои ощущения, то вот тут как раз и возникли проблемы.<br>
Как-то мой коллега сказал, что когда пробуешь VSCode после продуктов JetBrains, ощущения схожи с тем, когда пересаживаешься с иномарки на отечественный автопром. При всем уважении к VS Code и отечественному автопрому, в какой-то степени я могу понять его сравнение.</p>
<p>И дело даже не в том, что чего-то не хватает, или что-то не работает. Но помните, я писал чем в былые времена IDEA отвоёвывала пользователей у Eclipse? Более качественным автодополнением, автогенерацией и анализом кода.<br>
Порой казалось, что IDEA лучше тебя знает что ты хочешь написать дальше: в выпадающем списке автодополнения нужные варианты всегда были на первых местах. IDEA могла сама исправить огромное количество ошибок, сгенерировав правильный вариант. Иногда даже казалось, что я постепенно забываю синтаксис языка: проще было написать какую-то ерунду, нажать Alt-Enter и выбрать вариант исправления в выпадающем списке – дальше IDE сделает всю работу за тебя.<br>
И это преимущество никуда не делось и по сей день. И именно таких ощущений мне не хватило в VS Code.</p>
<p>Если попробовать подвести краткий итог, то на мой взгляд главная проблема VSCode не в том, что он в чём-то плох, а в том, что он настолько вырос, что его на полном серьёзе можно сравнивать с платными аналогами. И ты уже не ждёшь, что он будет достаточно хорош, чтобы в нём работать. Ты ждёшь, что он будет настолько же хорош, как его платные собратья. И такие завышенные ожидания немного портят итоговое впечатление.</p>
<p>И придя к такому выводу, я решил, что раз уж я выбираю другую IDE, то сейчас самое время не пытаться найти идентичную замену, а попробовать что-то кардинально отличающееся от моего предыдущего опыта.<br>
Когда ещё может представиться такой шанс?</p>
<h2 id="а-про-что-статья-ах-да-про-vim">А про что статья?.. Ах да, про Vim.</h2>
<p>И вот мы наконец-то дошли до Vim.<br>
Я не буду рассказывать про то, что такое Vim, иначе это уже точно никто не дочитает до конца. Скажу только, что речь пойдет про Neovim, но, как и в случае с VS Code/VSCodium, для простоты я дальше буду писать Vim, подразумевая Neovim. А что это и в чём между ними разница, вы сможете легко нагуглить и без меня.</p>
<p>С Vim я знаком достаточно давно. Бывали такие ситуации, когда заходишь по ssh на какой-нибудь сервер, чтобы отредактировать конфигурационные файлы, а из редакторов там ничего нет кроме Vim. Поэтому пришлось подучить как делать основные вещи: переключаться между режимами, копировать/удалять строчки, искать по файлу, сохранять файл, и самое главное – выходить из Vim :)<br>
Если кто не знает, вопрос “как выйти из vim” – довольно популярный мем.</p>
<p>Но надо понимать, что Vim – это гораздо большее, чем просто редактор текста. Я бы сказал, что Vim – это целый культ, может быть даже религия. Существует большая когорта разработчиков, которые используют для написания кода только Vim. Обычно в комплекте идёт любовь к работе в терминале, слепой метод печати и клавиатура без надписей на кнопках.<br>
В общем, что-то для меня довольно далёкое, но очень интересное.</p>
<p>Копнув глубже, я наткнулся на огромное количество статей и видеоуроков про то, как превратить Vim в полноценную IDE, не уступающую VS Code: с подсветкой кода, автодополнением и автоформатированием, с навигацией по файлам, интеграцией с git и дебаггером, с вкладками, экранами в режиме split view – со всем тем, чего ожидаешь от полноценного профессионального инструмента. При этом ты получаешь интересный бонус, так как Vim предлагает совершенно иной подход к работе с текстом.</p>
<p>Вообще, когда говорят про Vim, подразумевают две вещи.<br>
Первое – это vim motions. Второе – это сам редактор Vim.</p>
<p>Vim motions – это способ навигации по тексту и его редактирования с помощью горячих клавиш на клавиатуре. Считается, что если разработчик часто переключается между мышкой и клавиатурой, то это отнимает много времени, эффективность написания кода страдает. Поэтому Vim позволяет полностью исключить мышь из процесса работы с текстом.<br>
По началу такой подход кажется чем-то кошмарным. Но постепенно изучая новые возможности, понимаешь, что какие-то вещи делаются не только быстрее, но даже проще и удобнее! При этом никто не заставляет вас сразу полностью отказываться от мыши (хотя самые фанатичные апологеты Vim настаивают на отключении поддержки мыши в настройках редактора, чтобы максимально быстро приучить себя работать только с клавиатурой). Можно смешивать подход и изучать новые возможности постепенно. Главное – постоянно интересоваться как можно сделать то или иное действие в Vim без мыши и в следующий раз стараться делать подобные действия по-новому.</p>
<p>Если попытаться описать самую суть отличия редактирования текста в стиле Vim, то я сказал бы так:<br>
Когда работаешь с текстом, часто принимаешь решение куда нужно переместить курсор и что нужно удалить или дописать. Если начать проговаривать вслух эти решения, то скорее всего вы будете говорить что-то вроде “перемести курсор <em>сюда</em>” (тыкаете пальцем/мышкой куда), “а теперь добавь  строчку <em>тут</em>” (тыкаете мышкой куда), “удали вот <em>это</em>” (выделяете мышкой кусок текста).<br>
В Vim приходится учиться формализовывать свои желания: “перемести курсор <em>на три строки ниже</em>”, “скопируй <em>текущую строку</em> и вставь её копию <em>строкой выше</em>”, “перемести курсор <em>в конец названия функции</em> и удали <em>всё до конца строки</em>”.<br>
В моём случае основная сложность была (и есть до сих пор) не в том, чтобы выучить горячие клавиши, а в том, чтобы научиться налету формализовывать свои решения о перемещениях курсора и редактировании текста.</p>
<p>Vim motions настолько популярны, что существуют отдельно от редактора Vim. Есть другие “vim-like” редакторы, другие консольные программы с “vim-like” управлением (например, для навигации по файловой системе или для работы с git), есть плагины для IDEA и VS Code, добавляющие в них vim motions.<br>
Если интересно попробовать vim motions, не обязательно переходить на другой редактор кода, сначала поищите плагин для своего.</p>
<p>Что касается самого редактора Vim, то он сейчас переживает самый настоящий ренессанс. Связано это с появлением Neovim – форка Vim, в котором разработчики переписали часть устаревших частей, улучшили внутреннюю архитектуру и добавили возможность написания плагинов для редактора на языке Lua, вместо VimScript. И если раньше далеко не каждый любитель Vim решался изучать новый непонятный скриптовый язык, то Lua – достаточно простой и распространённый язык, чтобы привлечь новых желающих написать расширение для добавления какой-нибудь полезной (или не очень) функциональности в Vim.<br>
Это дало толчок к появлению огромного количества новых плагинов на любой вкус и цвет. Добавляем сюда потрясающую расширяемость, которая заложена в архитектуру Neovim, и получаем ситуацию, когда с помощью плагинов можно превратить Neovim в самую настоящую IDE со всеми прибамбасами, которые я упоминал выше.<br>
При этом вы получаете максимально персонализированную сборку рабочего инструмента, в котором настраиваете под себя абсолютно все: функциональность, внешний вид, горячие сочетания клавиш, поддержку языков и инструментов разработчика.</p>
<p>IDE, разработанная специально для вас, учитывающая все ваши желания и предпочтения.<br>
Заманчиво? Для меня – да. И я решил попробовать.</p>
<h2 id="начинаем-погружение">Начинаем погружение</h2>
<p>Как и в прошлом разделе начну с описания того, чего вы здесь не прочитаете. А именно здесь не будет примеров настройки, описания плагинов и прочего обучающего материала. Если кому-то будет интересно, я могу описать это в отдельной статье, хотя на просторах интернета и так достаточно статей по настройке Vim с нуля.<br>
Здесь же я хочу поделиться своим опытом: с чего начинал, что делал, на что обращал внимание, на что нужно было бы обратить внимание, к чему пришёл в итоге. Это вряд ли вам поможет сделать настройку своими силами, но даст общее представление о том, что вас ожидает, если вы пойдёте по такому же пути.</p>
<p>После установки и первого запуска Vim (напоминаю, что здесь и далее речь пойдет про Neovim) вы видите абсолютно голый текстовый редактор. В нём нет практически ничего, кроме базовой подсветки синтаксиса в самых распространённых типах файлов и поддержки тех самых vim motions, про которые я писал выше.<br>
В начале это даже вдохновляло – чистый холст, на котором можно написать произведение искусства так, как ты его видишь. Это ли не прекрасно?</p>
<p><img alt="Vim до конфигурирования"  src="/_astro/01-2-vim-without-config.2fc03dac_ZjIrDk.webp" width="1268" height="692" loading="lazy" decoding="async"></p>
<div class="img-text">Пример кода в Neovim до применения какой-либо конфигурации</div>
<p>Открываем обучающие материалы, закатываем рукава и начинаем творить:</p>
<ol>
<li>
<p>Сначала разбираемся с настройками, которые доступны “из коробки”: включаем отображение номеров строк (в относительном формате, чтобы знать на сколько строк сдвинуться вверх или вниз при использовании vim motions), включаем автозамену Tab на 4 пробела, добавляем подсветку текущей строки, прописываем директории, куда будет сохраняться история изменений (для сохранения undo между запусками), добавляем ещё с десяток полезных настроек и с первым пунктом покончено.<br>
Пришлось повозиться с официальной документацией и посмотреть несколько примеров у других, чтобы понять что может пригодиться, но это не так уж и сложно.<br>
Идём дальше.</p>
</li>
<li>
<p>Выбираем менеджер плагинов.<br>
Из коробки в Vim нет менеджера плагинов, его реализация также отдана на откуп коммьюнити. Каждый может выбрать себе что-то по душе.<br>
На тот момент, когда я разбирался с настройкой, ситуация обстояла следующим образом: долгое время был популярен менеджер плагинов под названием packer. Во многих инструкциях можно было встретить примеры его использования. Но в последнее время всё больше и больше пользователей стало отдавать предпочтение менеджеру плагинов lazy.nvim, который добавляет возможность ленивой инициализации расширений. Благодаря этому можно установить сколько угодно плагинов для различных задач, но они не будут тормозить первый запуск и не будут раздувать программу в памяти, так как будут подгружаться только тогда, когда реально понадобятся.<br>
Я решил остановиться на втором варианте, так как он выглядел более перспективно. Поговаривали, что даже автор packer в своей конфигурации Vim уже перешёл на lazy.nvim.<br>
Правда такой выбор добавил в дальнейшем проблем: для lazy было меньше мануалов и меньше примеров. Порой приходилось самостоятельно преобразовывать примеры конфигурации плагинов с варианта для packer на вариант для lazy. Cо временем, когда лучше разбираешься как устроен менеджер плагинов, делать это становится всё проще и проще, но в начале пришлось повозиться.<br>
Отмечу, что на данный момент автор packer заархивировал свой репозиторий и предлагает всем переходить на lazy, поэтому сейчас альтернативы вроде как уже и нет.<br>
<span class="line-gap">Для добавления менеджера плагинов потребовалось создать файл и скопировать в него lua код из мануала для установки и инициализации. Дальше для установки плагинов нужно создавать lua файлы и прописывать в них конфигурацию подгружаемых расширений.<br>
C этим шагом разобрались, продолжаем.</span></p>
</li>
<li>
<p>Театр начинается с вешалки, а современные редакторы – с выбора цветовой схемы. Тратим какое-то время, выбираем из сотни вариантов. Можно было взять darcula, которой я был доволен в IDEA, но новый редактор – новая жизнь. Остановился на не очень популярной, но на мой взгляд красивой теме под названием nordic. Копируем конфигурацию к себе в lua файл, перезапускаем редактор – готово!<br>
Двигаемся дальше.</p>
</li>
<li>
<p>Теперь займёмся внешним видом и дополнительными возможностями редактора.<br>
Нужен плагин для отображения папок проекта в древовидной структуре. И плагин для поиска по проекту. И плагин для настройки статусной строки внизу. Ещё плагин для работы с терминалом, не выходя из Vim. А также плагин для интеграции с git. Чтобы редактор автоматом добавлял закрывающие кавычки/скобки, когда печатаешь открывающую кавычку/скобку, тоже нужен плагин. И для добавления возможности комментирования/раскомментирования строк горячими клавишами тоже нужен плагин. Захотелось автосохранения файлов? Думаю уже понятно, что нужно делать.<br>
Я всё ещё <em>настраиваю</em> свою IDE или уже <em>разрабатываю</em> её? Никогда не задумывался, как много всего преднастроено в IDE из коробки.<br>
<span class="line-gap">На этот пункт я потратил около 3х-4х дней. Да-да, 3-4 полноценных дня, когда я весь день только и делал что разбирался с плагинами: как их установить, как настроить, а в некоторых случаях и как  проинтегрировать их между собой. Всё это делается путём написания Lua кода.<br>
Из плюсов – знать Lua не обязательно. Если знаком с любым другим языком программирования, то скорее всего сложностей не возникнет. В основном всё копируется из примеров и дорабатывается напильником по информации со stackoverflow и reddit.<br>
Из минусов – моя конфигурация постепенно становится похожа на полноценный небольшой проект на Lua. Со всеми вытекающими последствиями, о которых поговорю чуть позже.</span></p>
</li>
</ol>
<p>Итак, спустя примерно неделю изучения и написания кода для конфигурации я получил работающий инструмент, в котором я могу просматривать и редактировать текстовые файлы, быстро навигироваться по ним, удобно работать с репозиторием и терминалом. Я знаю как всё устроено внутри, как всё настроено, я прописал каждый хоткей самостоятельно и знаю их всё наизусть (либо знаю как быстро вспомнить, для этого есть всплывающие подсказки, конечно же с помощью ещё одного плагина).<br>
Вроде ничего не забыл? Ах, да…</p>
<h2 id="продолжаем-погружение">Продолжаем погружение</h2>
<p>Мы же не с текстом собираемся работать, а с кодом. Значит нам нужна поддержка языков программирования. Из чего она состоит?<br>
Я снова не буду углубляться в детали и технические подробности, но хочу отметить вот что: в процессе настройки мне <em>пришлось</em> погрузиться во все эти детали. Когда в мануале пишут, что нужно установить tree-sitter и lsp сервер – это, конечно, здорово. Но что это и для чего? Зачем нужны оба? Может хватит чего-то одного, а может нужно что-то ещё?<br>
Чтобы узнать ответы на эти вопросы, пришлось снова садиться за изучение дополнительной информации.</p>
<p>Итак, поддержка кода состоит из следующих частей:</p>
<ol>
<li>
<p>Подсветка синтаксиса.<br>
Для этого нужен тот самый tree-sitter – библиотека, которая парсит текст и раскрашивает его в различные цвета согласно синтаксису конкретного языка. Очень быстрый, очень легковесный, поддерживает всё, что только можно поддерживать, безальтернативный must-have плагин для Vim, даже если вы не хотите делать из редактора здоровенную IDE, а просто хотите с комфортом просматривать конфигурационные файлы.<br>
Установив tree-sitter, нужно установить поддержку синтаксиса нужных языков. Даже если вы работаете только с одним языком, например, Python, вам также может понадобиться: SQL, JSON, XML, YAML, TOML, Dockerfile. Хотите ещё и страничку-другую на React написать? Список значительно вырастет.<br>
Для моих нужд пришлось установить 40 (сорок!) языковых плагинов для tree-sitter. И да, если вы не заметили, мы уже начали устанавливать плагины для плагинов.</p>
</li>
<li>
<p>Автодополнение кода.<br>
Для добавления такой функциональности нам потребуется LSP сервер. LSP – Language Server Protocol – это то, за что действительно стоит поблагодарить Microsoft, которые придумали выделить поддержку языка из текстового редактора в отдельный сервер и разработали протокол, по которому языковой сервер может общаться с текстовым редактором.<br>
Таким образом разработчики языка могут написать сервер согласно протоколу LSP для своего языка, и поддержка языка станет доступна во всех редакторах, которые также поддерживают этот протокол со своей стороны. А значит такие функции как автодополнение кода, генерация кода, анализ ошибок и автоисправление этих ошибок будут схожими во всех редакторах и будут на том уровне, который реализовал разработчик языка, а не на том, который смог реализовать разработчик редактора.<br>
<span class="line-gap">Что это означает для нашей конфигурации? Правильно, больше плагинов: плагин для поддержки LSP, плагин для отображения выпадающего списка с автодополнениями, и плагин, занимающийся установкой LSP серверов для разных языков.<br>
Дальше устанавливаем сами сервера (их все же меньше, чем 40, но тоже много), попутно добавляем еще плагин для интеграции сниппетов в выпадающие списки автодополнения, и плагин для возможности автодополнять пути файловой системы (например, для удобной работы с директивами require/import в JS).</span></p>
</li>
<li>
<p>Автоформатирование.<br>
Какие-то языки имеют строгие правила форматирования исходного кода, какие-то – нет. Поэтому для каких-то языков эти правила встроены в сам LSP сервер, а для каких-то нужно устанавливать дополнительные инструменты, которые вносят собственные правила форматирования и обеспечивают хоть какое-то однообразие в проекте.<br>
Значит нам нужен плагин для интеграции редактора с этими инструментами, плагин для установки этих инструментов, и сколько-то строчек конфигурации для интеграции всего со всем. Иногда для одного языка требуется сразу несколько форматировщиков, например для форматирования текста программы – один, а для сортировки/оптимизации списка импортов – другой.</p>
</li>
<li>
<p>Статические анализаторы кода.<br>
Их ещё называют linters. Если вы написали что-то синтаксически неправильное, LSP сервер вам подскажет. Но зачастую можно написать что-то, что корректно с точки зрения синтаксиса, но некорректно с точки зрения здравого смысла. Самое простое – конструкции вида if false -> then. Современные линтеры достаточно глубоко анализируют код, выявляя довольно серьёзные ошибки, которые по невнимательности могут допустить даже самые опытные программисты.<br>
Снова изучаем что нужно для каждого языка и ставим плагины.</p>
</li>
</ol>
<p>Да, моя ситуация сильно осложнилась тем, что я хотел сразу собрать себе инструмент для всего подряд. Если вы в основном работаете с одним-двумя языками программирования, то вам будет проще, так как нужно будет настраивать сильно меньше всего. Но сколько бы языков вы не пытались настроить, для всех вы скорее всего захотите установить инструменты из всех 4х пунктов, чтобы обеспечить максимально возможную поддержку вашего языка редактором.<br>
Я мог бы установить только самое часто используемое и отложить настройку остального на потом. Но нужно понимать, что добавление поддержки нового языка занимает не 3-4 щелчка мыши, как в случае с VS Code или IDE от JetBrains. Мне потребовалось бы снова вспоминать все тонкости и залезать в код с конфигурацией по самые локти. Есть подозрение, что такая перспектива может отбить желание знакомиться с новым языком, как бы он ни заинтересовал :)</p>
<p><img alt="Vim после конфигурирования"  src="/_astro/01-3-vim-ide.991c34ea_IrxqA.webp" width="1268" height="692" loading="lazy" decoding="async"></p>
<div class="img-text">Пример кода в Neovim после превращения его в IDE</div>
<p>Но вот все сложности героически преодолены и кажется, что теперь всё на месте.<br>
Можно открыть новый проект и насладиться результатом!<br>
Или…</p>
<h2 id="идём-на-дно">Идём на дно</h2>
<p>Как я однажды отметил, конфигурация стала все больше и больше напоминать небольшой проект по разработке продукта.</p>
<p>А что бывает при разработке продукта?<br>
Дефекты.</p>
<p>И по закону подлости проблемы начинают вылезать в самый неподходящий момент. Настроился быстро накидать небольшой веб сайтик? Извини, что-то отвалилась поддержка Tailwind CSS. И автоформатирование astro файлов не работает. И подсветка YAML пропала. В dockerfile отображаются ошибки там, где их нет.<br>
Ой, теперь Vim вылетел.</p>
<p>Дефекты повсюду:</p>
<ol>
<li>
<p>Дефекты моей конфигурации.<br>
Когда писал конфиги, я открывал проект с нужным языком программирования и постоянно всё проверял. Но чем больше всего настраиваешь, тем меньше шансов всё проверить.</p>
</li>
<li>
<p>Дефекты, связанные с моим окружением.<br>
Бывало делаешь все по инструкции, а при заходе в файл с каким-нибудь языком Vim начинает ругаться километровыми ошибками. Оказалось, что именно на моем дистрибутиве linux и именно с тем пакетным менеджером, которым я устанавливал сам Neovim, есть проблемы у некоторых LSP серверов: сервер не может найти библиотеки gcc операционной системы и падает.<br>
Знаете сколько времени потребовалось, чтобы узнать что проблема именно в этом? Я даже не уверен, что я до конца понимаю смысл того, что я написал. Просто так было написано в посте, который я нашёл примерно на 3й странице выдачи в reddit при поиске проблемы по симптомам.</p>
</li>
<li>
<p>Дефекты плагинов, дефекты Neovim, дефекты LSP, форматтеров, линтеров и всего остального.<br>
Слишком много движущихся частей собрано воедино. Если плагин интегрирует Neovim с другим инструментом, например, для форматирования кода, то ему приходится иметь дело и с изменениями в самом редакторе, и с изменениями в форматтере, и еще свою функциональность развивать. И никто ни с кем не согласовывает релизы и изменения, нарушающие обратную совместимость.<br>
Да, можно попытаться найти конкретные версии всех плагинов, которые идеально работают между собой, зафиксировать их в конфиг файле и никогда больше не обновляться. Но это утопия. В таком большом наборе плагинов ежедневно исправляются старые дефекты и добавляется новая функциональность с новыми дефектами. И ты постоянно хочешь получать эти исправления. А значит нужно постоянно выделять время на то, чтобы обновляться и решать новые проблемы.</p>
</li>
</ol>
<p>Я хотел персонализированную IDE? Я получил её. Я собрал её самостоятельно.<br>
Но это значит, что и за качество этой сборки тоже отвечаю я.<br>
Я и разработчик, и релиз менеджер, и тестировщик. Такой вот побочный эффект.</p>
<p><img alt="Ошибка при старте Vim"  src="/_astro/01-4-vim-error.bf7858c6_Z15I2i7.webp" width="1268" height="692" loading="lazy" decoding="async"></p>
<div class="img-text">Иногда при запуске Vim может быть неприветлив</div>
<p>И что теперь со всем этим делать? Смириться и время от времени разбираться с ошибками?<br>
Попробуем поискать решение.</p>
<h2 id="забрезжил-свет">Забрезжил свет?</h2>
<p>Я немного слукавил. Я не довел свою настройку Vim до конца. Я настроил все нужные мне плагины для UI и для самого редактора, но на настройке LSP для разных языков я сильно затормозил.<br>
Я сделал примерно половину, после чего у меня опустились руки. Плагины пишут люди, такие же как мы с вами. И документацию к своим плагинам пишут люди. У кого-то документация простая и понятная, у кого-то из рук вон плохая. У кого-то описаны все вариации, а кто-то ссылается на код, мол разбирайтесь по исходникам.<br>
Вдобавок требуется хорошо знать инструменты для того языка, поддержку которого ты настраиваешь. Если я только вчера решил поизучать Go, то как я могу знать, сколько LSP серверов, форматтеров и линтеров мне надо подключить, чтобы получить максимальную языковую поддержку?<br>
Никак. Либо изучай, либо смотри туториалы на ютубе и слепо копируй их (если повезёт найти туториал под твой менеджер плагинов и те плагины для поддержки LSP и автодополнения, которые ты выбрал), либо начинай с функциональности блокнота с подсветкой синтаксиса и добавляй плюшки по мере изучения.<br>
Что же делать, если хочется всё и сразу, желательно настроенное умелыми руками разработчиков, которые на этом деле уже съели не одну свору собак?</p>
<p>И тут на сцену выходят готовые сборки IDE на базе Vim.<br>
Да, действительно есть такие “дистрибутивы” – написанные силами коммьюнити или отдельными энтузиастами конфигурации, в которые включены различные нужные плагины, настроен максимально широкий набор ЯП и все это заботливо задокументировано.<br>
Вот отличные, на мой взгляд, представители:</p>
<ul>
<li>LunarVim – очень популярная сборка, которая включает в себя довольно широкий набор плагинов для всего, что только душа может пожелать.</li>
<li>AstroVim – набирающая популярность сборка, которая помимо прочего фокусируется на эстетичности визуального интерфейса, а также позволяет устанавливать целые наборы плагинов одним пакетом, полноценно реализующим какую-то нужную функциональность.</li>
<li>LazyVim – сборка от разработчика менеджера плагинов lazy.nvim. Кто как не он может лучше знать, как максимально красиво и эффективно написать конфигурацию таким образом, чтобы её можно было легко поддерживать и развивать в дальнейшем?</li>
</ul>
<p>Ну и чего же ты нам голову морочил, спросите вы.<br>
Вот же решение – та самая сборка, за которую берут ответственность поставщики этой сборки, а не ты. И разбираться ни в чём не надо, всё настроено за тебя.</p>
<p>Всё так.<br>
Почти.</p>
<p>Сейчас, оглядываясь назад, мне кажется, что готовые сборки Vim – это самое противоречивое, что есть в этой экосистеме.<br>
Но давайте по порядку.</p>
<p>Про сборки Vim я узнал в самом начале своего пути. Более того, именно через них я и узнал о возможностях Vim – натолкнулся на видео на youtube, где автор рассказывал про возможности AstroVim.<br>
Увиденное мне так понравилось, что я решил разобраться в этой теме. Дальше я много читал, много смотрел туториалов и в итоге решил написать свою конфигурацию.<br>
Почему?</p>
<ol>
<li>
<p>Vim – это максимально персонализированный редактор кода. IDE, которую как будто разработали исключительно для тебя. Помните такое?<br>
Используя готовую сборку, ты как будто отказываешься от главного преимущества, которое предлагает тебе Vim.<br>
Знающие люди могут возразить, что сборка не запрещает, а скорее даже поощряет дополнительную настройку с целью персонализации. Ты всегда волен изменить какие-то параметры, удалить имеющийся плагин, установить новый.<br>
Да, но в этом случае возникает проблема номер 2.</p>
</li>
<li>
<p>Сборки обычно предлагают свой способ конфигурирования плагинов.<br>
Предполагается, что это сделано для простоты и легкости погружения новичков. Т.е. кто-то продумал что может понадобиться кому-то изменить и вынес эти настройки в переменные. Затем переменные вынес в отдельный файл и описал в документации перечень того, на что ты можешь повлиять.<br>
Звучит действительно удобно. Но лишь на первых порах.<br>
Такой подход заставляет вместо изучения стандартного подхода конфигурации Vim через Lua код изучать тот вариант конфигурирования, который придумали авторы сборки. Но эта надстройка никогда не будет такой же гибкой, как то, что можно сделать напрямую. И на просторах интернета решения проблем будут скорее всего описаны для конфигурации в Lua. Поэтому рано или поздно всё равно придётся лезть в код. И получать проблему номер 3.</p>
</li>
<li>
<p>Сложность изучения готовой конфигурации такого объёма.<br>
Вы ещё не забыли сколько всего я перечислил, что потребовалось установить и настроить? В готовых сборках обычно добавлено ещё больше всякой всячины для красоты и удобства.<br>
А теперь представьте, что вся эта конфигурация сваливается на вас разом.<br>
Для меня самый лучший способ изучить что-то – сделать своими руками. Когда открываешь большой готовый продукт, то не всегда понятно что в нём есть, чего нет, как можно что-то поменять.<br>
Но когда перед тобой голый Vim, ты видишь результат каждого своего изменения, каждой строчки кода. И шаг за шагом, добавляя новую функциональность, ты постепенно изучаешь особенности работы каждого плагина и работы с плагинами в целом. И это очень сильно пригождается при разборе каких-то проблем или попытке добавить какую-то нестандартную конфигурацию.<br>
Я не представляю как можно всё это понять, открыв готовую конфигурацию сборки.</p>
</li>
</ol>
<p>Ладно, ладно. Лишь сейчас я могу сформулировать эти проблемы.<br>
На момент старта мне просто захотелось хардкора и возможности в будущем слегка небрежно упоминать, что я написал свою конфигурацию с нуля, как это принято среди Vim корифеев :)</p>
<p>Поэтому я с головой ушёл в изучение всего, что описал выше и… абсолютно не прогадал!<br>
Да, не смотря на то, что в итоге я потратил много времени на настройку и пришел к ситуации, когда уже хотелось либо все бросить, либо взять готовую конфигурацию, я считаю что именно такой подход дал мне хорошее понимание того, что мне нужно от готовой сборки и как я буду её донастраивать.</p>
<p>И это, на мой взгляд, самый большой парадокс, связанный с готовыми сборками Vim: их рекомендуют для новичков для более быстрого старта, чтобы без больших вложений сил они могли получать что-то готовое.<br>
Но нужно обладать хоть каким-то опытом и знаниями конфигурирования Vim, чтобы готовую сборку действительно заточить под себя, а не оставить ее так, как для тебя настроили другие.</p>
<p>В итоге, бросив свою конфигурацию (простите, Vim корифеи), я выбрал LazyVim, так как подход к конфигурации мне был ближе всего, преднастроенные хоткеи были ближе к моему варианту, а значит меньше нужно было переопределять. Да и вообще при изучении я часто опирался на примеры того, как это сделано в LazyVim, поэтому миграция моей конфигурации произошла быстро и практически беспроблемно.</p>
<p>Решило ли это мои все мои проблемы? Конечно нет.<br>
Это ведь затронуло только один из проблемных пунктов – необходимость писать, обновлять и тестировать конфигурацию самому. Проблемы, связанные с gcc библиотекой, я получил уже после переезда на LazyVim. И дефекты в самих плагинах никуда не делись.<br>
Но к этому времени я уже достаточно много для себя понял, поэтому можно сделать выводы.</p>
<h2 id="выводы">Выводы</h2>
<p>Дорогой читатель, если ты дочитал до этого момента, то моё тебе большое уважение и благодарность. Если же ты пропустил весь текст и сразу перемотал к выводам – тоже ничего, скорее всего я сделал бы точно так же :)</p>
<p>Итак, сначала коротко о главном:</p>
<ul>
<li>
<p>Понравилось ли мне использовать Vim в качестве IDE?<br>
Да, однозначно понравилось. Несмотря на все проблемы, это был очень интересный опыт, открывший для меня много нового. Я проникся большой симпатией к vim motions и к легковесности консольных редакторов.</p>
</li>
<li>
<p>Не жалею ли я, что ввязался во всю эту историю со своей конфигурацией?
Нет, абсолютно не жалею. За это время я узнал много таких вещей, о которых раньше не задумывался.<br>
Это касается и внутренней работы IDE, и того, как много всего я обычно использую, считая это стандартным функционалом IDE, в то время как это было скрупулёзно продумано, разработано и оттестировано разработчиками.<br>
А разбираясь с различными LSP и инструментами для различных языков, начинаешь узнавать как всё устроено “под капотом”.<br>
Я даже сделал некоторое улучшение в одном из понадобившихся мне плагинов и засабмитил PR на GiHub. После этого пользоваться этим плагином стало вдвойне приятнее :)<br>
<span class="line-gap">Иногда IDE для нашего удобства прячет от нас слишком многое. Да, это снижает порог входа для новичков. Да, это помогает в ежедневной работе сосредоточиться на главном - написании кода. Но, безоговорочно полагаясь только на IDE, порой мы так и живём с непониманием как всё устроено внутри и связано друг с другом.</span></p>
</li>
<li>
<p>Можно ли использовать Vim в качестве IDE?<br>
Да, конечно. Очень много людей его так и используют. И готовые сборки используют, и сами пишут конфигурации.<br>
Проблемы всегда могут возникнуть, даже с платными продуктами. Если не ставить огромное количество плагинов, которые делают ненужную ерунду, планировать свои обновления, а не качать новые версии каждое утро, если побороть первичные болячки, которые вылезают в первые одну-две недели плотной работы с редактором, то на итог ты получаешь очень интересный, персонализированный продукт, который позволяет взглянуть на твою работу под другим углом и научиться чему-то новому.<br>
Ах, да. Только не заглядывайте в список открытых дефектов для выбранных плагинов, поберегите свои нервы :)</p>
</li>
<li>
<p>Что же всё-таки выбрать: свою конфигурацию или готовую сборку?<br>
Вопрос непростой, но я бы всё-таки рекомендовал попробовать сделать свою конфигурацию, особенно если вам не нужна поддержка большого количества языков.<br>
Есть прекрасная отправная точка – <a href="https://github.com/nvim-lua/kickstart.nvim" rel="nofollow noreferer noopener" target="_blank">kickstart.nvim</a>. Это шаблон конфигурации, который начинает с простого, всё детально описывает и даёт примеры как и куда двигаться дальше для дальнейшего расширения. Таким образом с самого начала получаешь что-то рабочее, а дальше конфигурация растёт вместе с твоими знаниями.<br>
Даже если вы не хотите выделять очень много времени на всё это дело, потратьте столько времени, сколько сможете. И чем больше знаний при этом вы получите, тем проще вам будет в дальнейшем, даже если вы перейдёте на готовую сборку.</p>
</li>
<li>
<p>Буду ли я и дальше использовать Vim в качестве IDE?<br>
Скорее всего нет. И об этом ниже чуть подробнее.</p>
</li>
</ul>
<p>Какой я сделал самый главный вывод для себя из всей этой истории?<br>
Главный вывод заключается в том, что я не учусь на своих ошибках с первого раза :)</p>
<p>Помните, когда я писал про VS Code, я сказал, что проблема в том, что я хочу, чтобы он был таким же, как IDEA.<br>
Дак вот VS Code – не IDEA. А Vim – не VS Code.<br>
Решив вместо VS Code поискать для себя что-то отличающееся от моего предыдущего опыта, я в процессе забыл, что Vim – это нечто сильно иное, чем то, что я использовал ранее. И делать из Vim VS Code – значит всё время пытаться достигнуть недостижимого.</p>
<p>Да, благодаря мощной системе плагинов из Vim действительно можно сделать что-то похожее на VS Code. Правда в этом случае скорее всего на выходе получится раздутая конфигурация, которую нужно поддерживать, необходимость обновляться чаще, чем это требовалось бы при ограниченном наборе плагинов, дефекты и вылеты.</p>
<p>Но есть и другой подход. Надо лишь вспомнить, что Vim – это консольный редактор, а значит работать с ним я буду в консоли. Поэтому не обязательно пытаться привнести различные инструменты в сам Vim, можно использовать эти инструменты в той же консоли отдельно от Vim.<br>
Например, для MacOS есть отличный эмулятор терминала – iTerm2. Он позволяет открывать новые сессии как в отдельных вкладках, так и в отдельных панелях в режиме split view. Если iTerm2 не устраивает, либо нет возможности его использовать, можно посмотреть в сторону терминальных мультиплексоров – Tmux или Zellij. Они добавят удобную работу с вкладками и сессиями в любой выбранный вами терминал.<br>
И вот уже становится не нужен плагин для работы с терминалом из Vim. И клиент для работы с git тоже можно открыть на отдельной вкладке. Да даже древовидную структуру файлов проекта можно просматривать в отдельной программе, открытой в отдельной панели терминала, а не в самом Vim.<br>
В итоге моя IDE – это не Vim. Моя IDE – это консоль со множеством удобных и проверенных временем консольных инструментов. А Vim выступает в роли редактора кода лишь как один из компонентов этого набора.</p>
<p>Почему же я тогда не буду использовать Vim и дальше?<br>
На сайте Neovim написано, что Neovim – это сверхрасширяемый текстовый редактор. И это самое точное определение, на мой взгляд.<br>
Neovim – это в первую очередь <em>текстовый</em> редактор, из которого можно слепить что угодно с помощью расширений, в том числе и редактор <em>кода</em>, максимально персонализированный и заточенным под свои нужды.<br>
Но в какой-то момент я понял, что у меня нет каких-то уникальных персональных потребностей и предпочтений. Мне нужен классический редактор кода с подсветкой синтаксиса, автодополнением, просмотром документации во всплывающих подсказках и возможностью быстрой навигации между функциями/классами/файлами. И я трачу очень много времени и сил, чтобы с помощью плагинов превратить Vim во вполне себе стандартный редактор кода.<br>
Мне понравился опыт работы в консольном редакторе, мне понравились vim motions, мне понравилась возможность кастомизации редактора в разумных пределах. Но я не хочу, чтобы для получения более или менее базовой функциональности редактора кода мне нужно было писать конфигурацию из десятков файлов и сотен строк кода. Я не хочу устанавливать десятки разнородных зависимостей, чтобы настроить то, что некоторые другие редакторы кода предоставляют “из коробки”. И получается, что мне не нужна эта сверхрасширяемость для интеграции с другими инструментами, так как я не хочу делать из Vim комбайн в стиле VS Code или IDEA.</p>
<p>И с такими мыслями я снова посмотрел на альтернативы. И нашел для себя Helix Editor – консольный vim-like редактор.<br>
Он ещё очень молод и ему много чего еще не хватает. У него ещё нет возможности устанавливать плагины (наконец-то можно отдохнуть от плагинов), а древовидное отображение файлов проекта добавится только в следующем релизе.<br>
Но без всего этого в нём есть процентов 80 от функциональности, которую я получил в Vim только к концу первой недели изучения возможностей конфигурирования. И всё это просто работает. А это именно то, чего я ожидаю от хорошего редактора кода.</p>
<p>Что касается Vim, то я очень рад, что открыл для себя этот немного безумный, но очень интересный мир. Я узнал много нового, наконец-то полноценно познакомился с vim motions и на итог пришёл к Helix только благодаря активному комьюнити Vim, которое смогло заинтересовать меня.<br>
Я буду и дальше следить за новостями из мира Vim, так как мне интересно в каком направлении это всё будет развиваться. Кто знает, как всё повернётся в дальнейшем?<br>
Быть может со временем у меня появятся такие потребности в кастомизации, которые не смогут удовлетворить другие редакторы. И тогда, возможно, я снова вернусь к Vim, так как знаю, что ему по силам всё что угодно.</p>
<p><br>P.S. Хочу выразить огромное уважение всем тем людям, которые на голом энтузиазме в своё свободное время пишут все эти многочисленные плагины, которые позволяют достичь совершенно невероятных результатов. Порой всё, что они получают в ответ – это жалобы на дефекты, претензии к документации и требования реализовать новые вещи как можно быстрее. Но именно на таких людях держится этот самобытный пласт культуры. За что им огромное спасибо.</p> </article> <div class="mt-8 border-t border-header-blue/80"> <div class="mt-4"></div> <script async src="https://telegram.org/js/telegram-widget.js?22" data-telegram-discussion="SystemOutBlog" data-comments-limit="30" data-colorful="1" data-color="445D7B">
        </script> </div>  </section> <button id="toTopBtn" title="Наверх" class="fixed bottom-4 right-5 z-40 hidden
        rounded-full border-2 border-sidebar-main/50 p-2.5 text-header-blue/70 shadow-md
        transition duration-150 ease-in-out
        hover:text-header-blue hover:shadow-lg active:border-sidebar-main active:bg-header-blue
        active:text-white sm:bottom-8 sm:right-8
        sm:p-3 xl:bottom-10 xl:right-12"> <svg class="w-[1.125rem] rotate-[270deg] hover:scale-110 sm:w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M7.15 21.1q-.375-.375-.375-.888q0-.512.375-.887L14.475 12l-7.35-7.35q-.35-.35-.35-.875t.375-.9q.375-.375.888-.375q.512 0 .887.375l8.4 8.425q.15.15.213.325q.062.175.062.375t-.062.375q-.063.175-.213.325L8.9 21.125q-.35.35-.862.35q-.513 0-.888-.375Z"></path></svg> </button> <script lang="ts">
    const btn = document.getElementById('toTopBtn');
    btn.addEventListener('click', () => topFunction());

    window.onscroll = function () {
        scrollFunction();
    };

    function scrollFunction() {
        if (
            document.body.scrollTop > 500 ||
            document.documentElement.scrollTop > 500
        ) {
            btn.style.display = 'block';
        } else {
            btn.style.display = 'none';
        }
    }

    function topFunction() {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
</script> </main> </div> </body></html>